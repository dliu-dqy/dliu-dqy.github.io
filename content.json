{"meta":{"title":"DL-楽園","subtitle":"An Elysium","description":"","author":"DL","url":"http://dliu-dqy.github.io","root":"/"},"pages":[],"posts":[{"title":"RN学习笔记-3","slug":"RN学习笔记-3","date":"2020-05-24T13:28:09.000Z","updated":"2020-05-24T13:31:15.347Z","comments":true,"path":"2020/05/24/RN学习笔记-3/","link":"","permalink":"http://dliu-dqy.github.io/2020/05/24/RN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/","excerpt":"","text":"RN学习笔记-3RN的构成构成1 React根据条件进行渲染可以通过创建一个组件(func)来根据props内部的参数进行判断.最后,由render接收判断的结果并动态修改元素. 123456789101112131415161718192021function UserGreeting(props) &#123; return &lt;h1&gt;欢迎回来!&lt;/h1&gt;;&#125;function GuestGreeting(props) &#123; return &lt;h1&gt;请先注册。&lt;/h1&gt;;&#125;function Greeting(props) &#123; const isLoggedIn = props.isLoggedIn; if (isLoggedIn) &#123; return &lt;UserGreeting /&gt;; &#125; return &lt;GuestGreeting /&gt;;&#125; ReactDOM.render( // 尝试修改 isLoggedIn=&#123;true&#125;: &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;, document.getElementById('example')); 通过变量来渲染元素例如: 1const isLoggedIn = this.state.isLoggedIn; 通过定义一个新变量来存储元素 &amp;&amp;运算符在 JavaScript 中，true &amp;&amp; expression 总是返回 expression，而 false &amp;&amp; expression 总是返回 false。 因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染.如果是 false，React 会忽略并跳过它. 三目运算符? (true) : (false) 用法同上 阻止渲染令render返回null即可.此方法不会影响函数的其他方法的进行. 列表/Keys使用map()方法来创建列表1234const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((numbers) =&gt; &lt;li&gt;&#123;numbers&#125;&lt;/li&gt;); 创建一个数组参数,并利用map()函数与&lt;li&gt;&lt;/li&gt;标签相对应 KeysKeys 可以在 DOM 中的某些元素被增加或删除的时候帮助 React 识别哪些元素发生了变化。是每一个元素被赋予的一个独一无二的确定的标识通常使用数据的id作为Key,或者使用序列号索引 index. Key的声明位于在js代码块里,而非HTML代码块里12345678910111213141516171819202122232425262728function ListItem(props) &#123; const value = props.value; return ( // 错啦！你不需要在这里指定key: &lt;li key=&#123;value.toString()&#125;&gt; &#123;value&#125; &lt;/li&gt; );&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; //错啦！元素的key应该在这里指定： &lt;ListItem value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('example')); 其中Key在兄弟元素中是唯一的,但在全局中不一定唯一.将Key作为传递参数而非Props的属性看待因为Post 组件可以读出 props.id，但是不能读出 props.key. 可以在JSX中嵌入map() 等会儿去看看B+树了，数据库可真是个好东西，啧。","categories":[],"tags":[]},{"title":"RN学习笔记-2","slug":"RN学习笔记-2","date":"2020-05-09T13:07:30.000Z","updated":"2020-05-09T13:23:29.741Z","comments":true,"path":"2020/05/09/RN学习笔记-2/","link":"","permalink":"http://dliu-dqy.github.io/2020/05/09/RN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/","excerpt":"","text":"RN学习笔记-2RN的构成ps：上一章看漏了一个概念：自顶向下流动。这个概念的意思是，在类内部，属性（即参数）的传递方向是从父元素向子元素流动的。 构成1 ReactProps一种固定的参数，与上一章讲的state不同，其在函数内部是不可变的，是一个只读属性。跟state的区别是，props接收功能组件外部赋予的信息，而state负责在组件内部传输信息。 举个例子： 1234567891011121314151617181920212223242526272829class content extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name:\"233\" &#125; //这里规定了state内部的参数名。 &#125; render()&#123; return( &lt;div&gt; &lt;Attri bute = &#123;this.state.name&#125; /&gt; &lt;/div&gt; ); //返回一个div标签以及内容 &#125;&#125;class Attri extends React.Component&#123; render() &#123; return ( &lt;h1&gt;&#123;this.props.name&#125;&lt;/h1&gt; ); &#125; //规定了Attri属性的展示方式，即&lt;h1&gt;标签&#125;/* 类似于this.state.name=&gt;whis.props.name=&gt;&lt;h1&gt;内容 这样的流动方式*/ 验证props使用propTypes来验证参数的属性。如果是无效参数，则JS控制台给出警告，这时会强行转换格式。 12345678910111213Attribute.propTypes = &#123; a:propTypes.string&#125;;/*这段代码写在Attribute类中，起验证作用。其中a为设定好的属性。待验证的类型可以是多种多样的。既可以是类似于array，number，bool这种简单属性，也可以是node，elements这种待渲染的对象，或者是选定值(oneOf(['x','y']),oneOfType([React.Proptypes.string,React.Proptypes.number])）以及很多带有限定意味的定义式组合元素。*/ 事件处理几个很有React特色的约定。 1.绑定事件属性的命名法：与HTML常用的全小写不同，采用驼峰命名。 2.使用函数而不是字符串来作为事件处理函数。 3.与HTML中一旦函数返回false便不执行该事件不同，必须使用preventDefault来阻止。如： 123456789101112131415function ActionLink() &#123;//定义一个函数 function handleClick(e) &#123; e.preventDefault(); //这里定义为阻止这个函数执行 console.log('链接被点击'); //控制台跳出信息 &#125; return ( &lt;a href=\"#\" onClick=&#123;handleClick&#125;&gt;//调用函数 点我 &lt;/a&gt; );&#125; 事件中的属性绑定类的方法默认是不绑定this的，如果不手动绑定this的话，调用这个函数时this的值为undefined 解决方式： 1.this.method = this.method.bind(this); 利用bind()来绑定 2.属性初始化器予以绑定 1234567891011return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/button&gt; );//ORreturn ( &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt; Click me &lt;/button&gt; ); 后一种函数是 箭头函数* 的用法,不是很推荐使用。 向事件处理程序内部传参 1.调用内部函数 2.使用bind()绑定参数 这样一来主要的传参策略就可以得知了。 箭头函数表达式为ES6中的一种函数声明范式。var f = ([参数]) =&gt; 表达式（单一）等价于var f = function([参数]){return 表达式;}","categories":[],"tags":[]},{"title":"RN学习笔记-1","slug":"RN学习笔记-1","date":"2020-05-04T11:36:12.000Z","updated":"2020-05-04T13:04:30.463Z","comments":true,"path":"2020/05/04/RN学习笔记-1/","link":"","permalink":"http://dliu-dqy.github.io/2020/05/04/RN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/","excerpt":"","text":"RN的构成构成1 Reactreact是一个开源的JS框架，用于构建用户界面。 react的依赖库核心库：react.min.js DOM相关库：react-dom.min.js 什么是DOM？：文档对象模型，一种标准编程接口，将文档视作一个树形结构，树的每个结点表示了一个HTML标签或标签内的文本项。 react的最小可分单位是元素新添加一个div标签，标签交由根DOM节点管理，通过函数 1234const a = &lt;h1&gt;やばいです&lt;/h1&gt;ReactDOM.render(a,document.getElementById('xx'))//其中参数a是指由const定义的元素//后面第二个参数为一个定位函数，用以确定标签id名为xx的元素 1&lt;div id=\"xx\"&gt;&lt;/div&gt; 如何刷新元素元素是不可变的，更改的方法是创建一个新的元素，并传入render方法。 使用setInterval(func,time)方法，每time（单位为毫秒）事件后调用一次函数func 另一种方法：继承React.Component中的类，但感觉调用的层次更多了。好处在于可以用多层props来传多个值。 tip:React在render方法传入后会比较元素的不同之处，只渲染改变了的部分 JSX看起来像XML的语法扩展。用处是声明上文中提到的元素例句： 1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 可以将其编写为独立文件，并引入HTML文件里1&lt;script type=\"text/babel\" src=\"filename.js\"&gt;&lt;/script&gt; JS表达式与条件判断通过{}来应用 JavaScript 表达式与注释 通过三元运算符 1x==y?'1':'2' 来替代 if else 语句 样式推荐使用内联样式（即直接写在文件里） 1234var style1 = &#123;color = '#000000'&#125;;ReactDOM.render( &lt;h1 style = &#123;myStyle&#125;&gt;React&lt;/h1&gt; , document.getElementById('xx')); 数组默认自动展开所有成员： 12345678var arr = [ &lt;h1&gt;a&lt;/h1&gt;, &lt;h2&gt;b&lt;/h2&gt;,];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById('xx')); React的组件通过函数定义组件12function component_name (props)&#123; return yy; &#125;//这里的yy为HTML标签组件 通过继承class来定义组件12345class Welcome extends React.Component &#123; render() &#123; return yy; &#125;&#125; 自定义React类tip:原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头 12345function MyAttribute(props) &#123; return &lt;h1&gt;Hello &#123;props.name&#125;!&lt;/h1&gt;;&#125; //通过props.name来获取下文定义的nameconst element = &lt;MyAttribute name=\"A\"/&gt;; 复合组件就是通过大组件中调用小组件来输出多个原子组件 React state通过属性 1this.state 的改变来决定是否渲染页面 生命周期通过设置 Clock 组件第一次将 Clock 加载到 DOM 中的时候，生成定时器。称为挂载。 当 Clock 生成的这个 DOM 被移除的时候，清除定时器，称为卸载。 实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Clock extends React.Component &#123; constructor(props) &#123; //构造函数 super(props); this.state = &#123;date: new Date()&#125;; &#125; //在输出至DOM后调用 componentDidMount() &#123; this.timerID = setInterval( () =&gt; this.tick(), 1000 ); //这里挂载了一个定时器 &#125; //生命周期钩子1 componentWillUnmount() &#123; clearInterval(this.timerID); //卸载定时器 &#125; //生命周期钩子2 tick() &#123; this.setState(&#123; date: new Date() &#125;); &#125; //在构造函数执行后调用该方法 render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; ReactDOM.render( &lt;Clock /&gt;, document.getElementById('example')); 今天就看到这里吧。就当React入门惹 资料参考：www.runoob.com","categories":[],"tags":[]},{"title":"水月雨银色飞船简评","slug":"MoonDrop","date":"2020-04-24T11:38:36.000Z","updated":"2020-04-24T11:55:04.683Z","comments":true,"path":"2020/04/24/MoonDrop/","link":"","permalink":"http://dliu-dqy.github.io/2020/04/24/MoonDrop/","excerpt":"","text":"（以下内容均为极为主观的评价） 最近想换个新的入耳式，看到有很多人推荐着水月雨的银色飞船，一看也才109块，本着就当买牌子送耳机的想法，入手了。 说实话水月雨这个牌子我以前是没有听说过的，以前用过的入耳式耳机大部分都是铁三角，森海塞尔以及索法，尤其是铁三角，基本占据了曾用耳机的半壁江山。这些耳机覆盖150到900块的价格段，用以估计银船的大致价值区间 __铁三角 __IM50CKB50C550CKR30 森海塞尔Momentum In-EarCX2.00 索尼XB75APA1AP 听感音乐选用以下几首： Welcome To Va-11 Hall-AMEN OF DESTINYグーラ領チカっとチカ千花っ♡ 其中第一首是偏舒缓的Electro乐曲（也不尽然），鼓点以及电子琴的尾音比较考验结像能力，在我看来银船的结像能力是能划分到IM50这一档的。令人惊艳的是，银船很好地做到了分离不同频段的乐器，并不会有混在一起的感受。这一点，上面的一部分耳机是做不到的，比如说小馒头（点名批评），对比下来总有种解析力不足的感觉。缺点么，就是在低频的摩擦音转中高频的时候会有莫名其妙的刺音。 第二首是上个世纪的摇滚乐，出自高达0083，依旧是很强的分离功效，但感觉上，像是乐器是从不同的方向进入耳膜，人声交错着乐器进入耳膜，鼓点的爆发力很强。 第三首则是异度之刃2的背景音乐，宏大的多声部将声场极大地延伸，代入感极强。这一点与A1AP有相似之处。问题这次出现在了低音的瞬态上，看来低频是个绕不过去的坎了（笑）。 第四首则测试了甜美女声下的表现，感觉跟A1AP一比的话不够甜。但这一点其实也可以理解为没有加上太多音染。 结论是这款耳机基本在解析力上向IM50比肩，整体听感甚至达到了A1AP的水平（除去数码味） 99买亏不亏？一点都不亏，甚至算是做慈善了。（水月原话） 对水家的调音赞一个，总而言之挺符合我的口味的。 最后附上皂片","categories":[],"tags":[]},{"title":"RX78 GP03D 石斛兰","slug":"PhotoTest","date":"2020-04-16T11:41:34.000Z","updated":"2020-04-16T12:07:31.286Z","comments":true,"path":"2020/04/16/PhotoTest/","link":"","permalink":"http://dliu-dqy.github.io/2020/04/16/PhotoTest/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Blog-Initialized","slug":"hello-world","date":"2020-04-16T01:45:18.495Z","updated":"2020-04-16T11:37:58.236Z","comments":true,"path":"2020/04/16/hello-world/","link":"","permalink":"http://dliu-dqy.github.io/2020/04/16/hello-world/","excerpt":"","text":"第一篇博客，稍微写点规划吧 主要是为了记录一些好玩的东西，学习的积累，以及一些前端技术的实践。 短期的目标是实现ナツメ的Live-2d 就这样。","categories":[],"tags":[]}],"categories":[],"tags":[]}